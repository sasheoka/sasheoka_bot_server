## Локальная Работа с Git (Краткое Руководство)

После того как вы инициализировали Git (`git init`) и сделали первый коммит, вот основной цикл работы для отслеживания изменений в вашем проекте локально:

1.  **Внесение Изменений:**
    *   Редактируйте существующие файлы (`.py`, `.md` и т.д.).
    *   Создавайте новые файлы или папки.
    *   Удаляйте ненужные файлы.

2.  **Проверка Статуса (`git status`):**
    *   В любой момент откройте терминал в папке проекта и выполните:
        ```bash
        git status
        ```
    *   Эта команда покажет:
        *   `Changes not staged for commit:` (Файлы, которые были **изменены** с момента последнего коммита).
        *   `Untracked files:` (Новые файлы, о которых Git еще не знает).
        *   `Changes to be committed:` (Файлы, которые вы **добавили** в индекс (staging area) и готовы к коммиту).
        *   `nothing to commit, working tree clean` (Если текущее состояние файлов совпадает с последним коммитом).

3.  **Добавление Изменений в Индекс (`git add`):**
    *   Чтобы подготовить измененные или новые файлы к сохранению (коммиту), их нужно добавить в "индекс" (staging area).
    *   **Добавить конкретный файл:**
        ```bash
        git add имя_файла.py
        git add папка/другой_файл.txt
        ```
    *   **Добавить ВСЕ измененные и новые файлы** (кроме тех, что в `.gitignore`):
        ```bash
        git add .
        ```
        *(Используйте `git add .` с осторожностью, чтобы случайно не добавить временные или ненужные файлы, если `.gitignore` настроен неполностью).*
    *   После `git add` снова выполните `git status`, чтобы увидеть, что файлы переместились в секцию "Changes to be committed".

4.  **Сохранение Изменений (Коммит) (`git commit`):**
    *   Когда вы подготовили все нужные изменения в индексе, создайте "снимок" состояния проекта — коммит.
    *   Выполните команду, указав осмысленное сообщение после флага `-m`:
        ```bash
        git commit -m "Краткое описание сделанных изменений"
        ```
    *   **Примеры хороших сообщений:**
        *   `git commit -m "Fix quest history pagination bug"`
        *   `git commit -m "Add !ban command"`
        *   `git commit -m "Update README with new setup instructions"`
        *   `git commit -m "Refactor API request logic in snag_cog"`
    *   Старайтесь делать коммиты для логически завершенных изменений.

5.  **Просмотр Истории (`git log`):**
    *   Чтобы увидеть историю коммитов:
        ```bash
        git log
        ```
        *(Нажмите `q`, чтобы выйти из просмотра лога).*
    *   Для более краткого лога:
        ```bash
        git log --oneline
        ```
    *   Для лога с графиком веток (полезно при работе с ветками):
        ```bash
        git log --graph --oneline --all
        ```

**Основной Цикл:**

**Изменить -> `git status` -> `git add` -> `git status` -> `git commit` -> Повторить**

**Дополнительные Полезные Команды (Локально):**

*   **`git diff`:** Показывает разницу между текущими изменениями в файлах и последним коммитом (для файлов, которые *еще не* добавлены в индекс через `git add`).
*   **`git diff --staged`:** Показывает разницу между файлами в индексе (после `git add`) и последним коммитом.
*   **`git checkout -- <имя_файла>`:** **ОСТОРОЖНО!** Отменяет *все* не добавленные в индекс (`git add`) изменения в указанном файле, возвращая его к состоянию последнего коммита. Изменения будут потеряны!
*   **`git reset HEAD <имя_файла>`:** Убирает файл из индекса (отменяет `git add`), но оставляет сами изменения в файле.
*   **`git branch <имя_ветки>`:** Создает новую ветку.
*   **`git checkout <имя_ветки>`:** Переключается на другую ветку.
*   **`git merge <имя_ветки>`:** Сливает указанную ветку в текущую.

Использование Git даже локально — мощный инструмент для организации работы и предотвращения потери данных.